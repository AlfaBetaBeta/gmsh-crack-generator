# gmsh plugin for crack generation in 3D FE meshes

This is a procedural version of a program to create cracks inside a solid 3D mesh generated by gmsh by duplicating tagged surface elements. It is based on python pandas and uses DataFrames and dictionaries as the main data structures.

The `.msh` file containing the (uncracked) solid mesh is the main input argument for the python script `crack.py`, which will return an updated `.msh` file embedding the cracks upon execution. The main caveats and limitations of the program are showcased below by means of a series of test examples.


## Introduction

Consider an overly simplistic mesh made of two quadratic hexahedrons, as shown below. For element-based FE engines, it might be necessary to assign two different physical tags to the solid elements: one tag (`"bulk"`) would identify the group, for convenient association with constitutive models to represent the material, and the other tag (`"solid_type_1"`) would convey information about the element's self weight. Typically these two strings would be programmatically processed when integrating the data into the FE engine, though they are given descriptive dummy values here for illustration. Although some FE engines may not require this type of element characterisation, the script in its current form expects double physical tagging for all solid elements.

<img src="https://github.com/AlfaBetaBeta/gmsh-crack-generator/blob/master/img/intro/pre-crack-pe-nodes-elmts.png" width=100% height=100%>

The surfaces to be duplicated need to be tagged as well. Although in this simplistic example there is only one feasible surface, in an extensive solid mesh many such surfaces may coalesce into a (possibly curved) crack surface. Each crack surface can have its own physical tag (here `"crack_horizontal"`) or they can share a common tag. The reason behind individual tagging is that, after duplication, each surface and its duplicate can be further transformed into a zero-thickness interface element and it may be convenient to differentiate between sets of crack surfaces (i.e. interface types) to assign them different material properties. The explicit transformation into interface elements is not addressed here, as it is FE engine dependent, but indication is made as to how it could be done wherever appropriate. Regardless of the number of physical tags for crack surfaces, **all** surfaces to be duplicated need to be grouped by a common tag (here `"s2in"`). Ultimately, this is necessary precisely to facilitate the definition of interface elements, as will become apparent with the examples.

Shifting focus back on the simplistic mesh, once `crack.py` is executed (caveats on execution syntax can be found in subsequent test examples), the tagged surface is duplicated, effectively decoupling the two adjacent solid elements. This is shown below, whereby a virtual crack opening is induced for visual clarity (in reality the duplicated nodes along the crack surface initially overlap in the same location). 

<img src="https://github.com/AlfaBetaBeta/gmsh-crack-generator/blob/master/img/intro/post-crack-nodes-elmts.png" width=100% height=100%>

The total number of nodes in the mesh has increased by 8, as expected (nodes 33-40 form the new surface) and 

Partitioning of the solid mesh can be dealt with, as the `make_crack()` function includes code to partition the crack surface elements accordingly.
      
A preprocessing function `preproc_df()` is included to ensure that the surface elements contained in the DataFrame `df_elm` have all a unique elementary tag.
      
Only solid elements bk20 (20-noded-hexahedron) and wd15 (15-noded-wedge) are considered. Should the mesh contain other types of elements (e.g. tt10/10-noded-tetrahedron), some functions would need updating.
      
It is assumed that any crack surface element can only have 2 physical tags (`*joint` group and `s2in` group). In theory a third tag could be present if any such surface were subject to restraints (e.g. r_x+z). This version cannot handle this yet.

If a continuous crackplane is curved, and depending on the ordering of the crack surface elements (which determines the ordering in which they are processed), the orientation of the crack (determining what is its 'top' and 'bottom') may become ambiguous. For now, inspection of the crack ordering in the .msh file via gmsh is necessary until a general solution is developed.

The main script needs 3 arguments:
* name of the `msh` file
* crack physical tags, with some pairs being possibly coupled if they belong to the same crack plane (e.g. `[1,[2,3],4]`)
* physical tags of the solids in the mesh, paired as itertuples
```
$ python crack.py example.msh [[12,13],[14,15,16,17,18],19] 1,20,5,20,7,20,8,20,9,23,10,20,11,24

$ ls
example.msh cracked_example.msh
```
The output will be an enhanced `msh` file, retaining the original file name prepended with `cracked_`.